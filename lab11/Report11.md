# Отчет по лабораторной работе № 11
## по курсу "Фундаментальная информатика"

Студент группы М8О-108Б-23 Соловьева Надежда Сергеевна

Работа выполнена 

Преподаватель: каф. 806 Севастьянов Виктор Сергеевич

1. **Тема**: Обработка последовательности литер входного текстового файла  
2. **Цель работы**: Составить программу на языке Си, выполняющую анализ и обработку вводимого текста в соответствии с выданным заданием.  
3. **Задание (Вариант №):** Вариант №31: Распечатать каждое третье двоичное число
4. **Алгоритм решения:**
   Программа работает в виде конечного автомата, который принимает посимвольно значения из потокового ввода и начинает работу в состоянии START. Каждый корректный символ записывается в строку word, которая обновляется для каждого нового слова. Каждое третье двоичное число записывается в общую строку res, которая в итоге  выводится.  
   Состояния:  
   - START: Если символ является 0 или 1 (т.е. может являться началом двоичного числа), то переход в состояние WORD.  
            Иначе, продолжаем искать корректный первый символ.  
   - WORD: Если символ является 0 или 1, то продолжаем принимать значения.  
           Если символ является разделителем (т.е. '\t', '\n', ' ', ','), то значит слово закончилось и оно корректно. Далее проверяем, что его номер (как двоичного числа) делится нацело на 3. И в случае деления нацело записываем это слово в общую строку с результатами res.  
           Иначе (т.е. введен некорректный символ), переход в состояние SPACE.  
   - SPACE: Если символ является разделителем (т.е. некорректное слово закончилось), то переход в состояние START.  
            Иначе, продолжаем искать разделитель.  
     В программе реализованы следующие функция isBinaryDigit(), которая проверяет, является ли символ числом из двоичной системы счисления.
5. **Тестовые данные:**

| Входные данные          | Выходные данные | Описание тестируемого случая                                                                                                                 |
|-------------------------|-----------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| 101     0,1,dhg 214 010 |                 |                                                                                                                                              |
| 10      11      11011   | 1 11 000        |Данный пример показывает, что программа делает корректную выборку символов, правильно обрабатывает разделители и выводит корректный результат |
| 00100 000 dsfhgs 1024   |                 |                                                                                                                                              |

   
7. **Протокол**:

    Программа на Си: [11.c](/11.c)  
```
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>

bool isBinaryDigit(char c) {
    return (c == '0' || c == '1');
}

int main() {
    enum State {
        START, 
        WORD, 
        SPACE
    };
    enum State state = START;

    char word[1000];
    int wordIdx = 0;
    int wordCount = 0;
    char input;
    char res[1000];

    while ((input = getchar()) != EOF) {
        switch (state) {
            case START:
                if (isBinaryDigit(input)) {
                    memset(word, 0, strlen(word) * sizeof(int));
                    word[wordIdx] = input;
                    wordIdx++;
                    state = WORD;
                }
                break;

            case WORD:
                if (isBinaryDigit(input)) {
                    word[wordIdx] = input;
                    wordIdx++;
                    } 
                else if (isspace(input) || input == '\n' || input == '\t' || input == ',') {
                    word[strlen(word) + 1] = '\0';
                    wordCount++;
                    if (wordCount % 3 == 0) {
                        int length = strlen(word);
                        int lenres = strlen(res);
                        for (int i = 0; i < length; i++) {
                            if (word[i] == '0' || word[i] == '1') {
                                res[i + lenres] = word[i];
                            }
                        }
                        res[lenres + length] = ' ';
                    }
                    wordIdx = 0;
                    state = START;
                }
                else {
                    wordIdx = 0; 
                    state = SPACE;
                }
                break;

            case SPACE:
                if (isspace(input) || input == '\n' || input == '\t' || input == ',') {
                    state = START;
                }
                break;
        }
    }
    int k = strlen(res);
    for (int i = 0; i < k; i++) {
        if (isspace(res[i]) || res[i] == '1' || res[i] == '0') {
            printf("%c", res[i]);
        }
    }
    return 0;
}
```

  Компиляция:
```
user@DESKTOP-IL3KD9K MINGW64 ~ (main)
$ cd repository

user@DESKTOP-IL3KD9K MINGW64 ~/repository (main)
$ cd lab11

user@DESKTOP-IL3KD9K MINGW64 ~/repository/lab11 (main)
$ gcc -std=c99 -Wall -pedantic 11.c

user@DESKTOP-IL3KD9K MINGW64 ~/repository/lab11 (main)
$ ./a
11 3465 1fjf 00 1 0 1111
000 11011 010 dhfg 10 0
01 01010 242 shf 10ef


1 000 10 01010
user@DESKTOP-IL3KD9K MINGW64 ~/repository/lab11 (main)
$ ./a
101     0,1,dhg 214 010
10      11      11011
00100 000 dsfhgs 1024

1 11 000
user@DESKTOP-IL3KD9K MINGW64 ~/repository/lab11 (main)
$
```
  
7. Вывод: В процессе работы закрепили навыки программирования на Си, освоили метод конечных автоматов. Лично для меня работа выдалась трудной, так как долго не могла понять принцип переходов состояний конечного автомата в Си. Но с Божьей помощью путём проб и ошибок у меня получилось, так что я очень рада.   
Итог: 8/10.   
